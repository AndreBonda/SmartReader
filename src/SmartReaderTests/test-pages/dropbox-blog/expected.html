<div id="readability-page-1" class="page"><div>
                            <div>
                                <p>
                                    I joined Dropbox not long after graduating with a Master’s degree in computer science. Aside from an internship, this was my first big-league engineering job. My team had already begun designing a critical internal service that most of our software would use: It would handle asynchronous computing requests behind the scenes, powering everything from dragging a file into a Dropbox folder to scheduling a marketing campaign.
                                </p>
                                <p>
                                    This Asynchronous Task Framework (ATF) would replace multiple bespoke async systems used by different engineering teams. It would reduce redundant development, incompatibilities, and reliance on legacy software. There were no open-source projects or buy-not-build solutions that worked well for our use case and scale, so we had to create our own. ATF is both an important and interesting challenge, though, so we were happy to design, build and deploy our own in-house service.
                                </p>
                                <p>
                                    ATF not only had to work well, it had to work well at scale: It would be a foundational building block of Dropbox infrastructure. It would need to handle 10,000 async tasks per second from the start, and be architected for future growth. It would need to support nearly 100 unique async task types from the start, again with room to grow. There were at least two dozen engineering teams that would want to use it for entirely different parts of our codebase, for many products and services.&nbsp;
                                </p>
                                <p>
                                    As any engineer would, we Googled to see what other companies with mega-scale services had done to handle async tasks. We were disappointed to find little material published by engineers who built supersized async services.
                                </p>
                                <p>
                                    Now that ATF is deployed and currently serving 9,000 async tasks scheduled per second and in use by 28 engineering teams internally, we’re glad to fill that information gap. We’ve documented Dropbox ATF thoroughly, as a reference and guide for the engineering community seeking their own async solutions.
                                </p>
                            </div>
                            <div>
                                <p id="introduction">
                                    <h2>
                                        Introduction
                                    </h2>
                                </p>
                            </div>
                            
                            <div>
                                <p id="glossary">
                                    <h2>
                                        Glossary
                                    </h2>
                                </p>
                            </div>
                            <div>
                                <p>
                                    Some basic terms repeatedly used in this post, defined as used in the context of this discussion.
                                </p>
                                <p>
                                    <b>Lambda:</b> A callback implementing business logic.
                                </p>
                                <p>
                                    <span><b>Task:</b> Unit of execution of a lambda. Each asynchronous job scheduled with ATF is a task.</span>
                                </p>
                                <p>
                                    <span><b>Collection:</b> A labeled subset of tasks belonging to a lambda. If <span>send email</span> is implemented as a lambda, then <span>password reset email</span> and <span>marketing email</span> would be collections.</span>
                                </p>
                                <p>
                                    <span><b>&nbsp;Priority:</b> Labels defining priority of execution of tasks within a lambda.&nbsp;</span>
                                </p>
                            </div>
                            <div>
                                <p id="features">
                                    <h2>
                                        Features
                                    </h2>
                                </p>
                            </div>
                            
                            <div>
                                <p id="system-guarantees">
                                    <h2>
                                        System guarantees
                                    </h2>
                                </p>
                            </div>
                            
                            <div>
                                <p id="-lambda-requirements">
                                    <h2>
                                        Lambda requirements
                                    </h2>
                                </p>
                            </div>
                            
                            <div>
                                <p id="architecture">
                                    <h2>
                                        Architecture
                                    </h2>
                                </p>
                            </div>
                            <div>
                                    <figure>
                                        <img src="https://localhost/cms/content/dam/dropbox/tech-blog/en-us/2020/11/atf/diagrams/Techblog-ATF-720x844px-1.png" aria-hidden="false" alt="Async Task Framework (ATF) [Fig 1]" height="1688" width="1440">
                                        <figcaption>
                                            Async Task Framework (ATF) [Fig 1]
                                        </figcaption>
                                    </figure>
                                </div>
                            <div>
                                <p>
                                    In this section, we describe the high-level architecture of ATF and give brief description of its different components. (See Fig. 1 above.)&nbsp;In this section, we describe the high-level architecture of ATF and give brief description of its different components. (See Fig. 1 above.) Dropbox <a href="https://dropbox.tech/infrastructure/courier-dropbox-migration-to-grpc">uses gRPC</a> for remote calls and our in-house <a href="https://dropbox.tech/infrastructure/reintroducing-edgestore">Edgestore</a> to store tasks.
                                </p>
                                <p>
                                    ATF consists of the following components:&nbsp;
                                </p>
                                
                                <p>
                                    <span><b>Frontend</b><br>
                                    This is the service that schedules requests via an RPC interface. The frontend accepts RPC requests from clients and schedules tasks by interacting with ATF’s task store described below.</span><br>
                                </p>
                                <p>
                                    <b>Task Store<br></b> ATF tasks are stored in and triggered from the task store. The task store could be any generic data store with indexed querying capability. In ATF’s case, We use our in-house metadata store Edgestore to power the task store. More details can be&nbsp;found in the <a href="https://paper.dropbox.com/doc/How-we-designed-Dropboxs-ATF-an-async-task-framework--A~wmq5aW48OkHns4LzkM~o6zAg-cf95JuxevqilF2iWWATj6#:uid=395988446153757833740421&amp;h2=Data-model">D</a><a href="https://paper.dropbox.com/doc/How-we-designed-Dropboxs-ATF-an-async-task-framework--A~wmq5aW48OkHns4LzkM~o6zAg-cf95JuxevqilF2iWWATj6#:uid=395988446153757833740421&amp;h2=Data-model">ata</a> <a href="https://paper.dropbox.com/doc/How-we-designed-Dropboxs-ATF-an-async-task-framework--A~wmq5aW48OkHns4LzkM~o6zAg-cf95JuxevqilF2iWWATj6#:uid=395988446153757833740421&amp;h2=Data-model">M</a><a href="https://paper.dropbox.com/doc/How-we-designed-Dropboxs-ATF-an-async-task-framework--A~wmq5aW48OkHns4LzkM~o6zAg-cf95JuxevqilF2iWWATj6#:uid=395988446153757833740421&amp;h2=Data-model">odel</a> section below.
                                </p>
                                <p>
                                    <b>Store Consumer<br></b> The Store Consumer is a service that periodically polls the task store to find tasks that are ready for execution and pushes them onto the right queues, as described in the queue section below. These could be tasks that are newly ready for execution, or older tasks that are ready for execution again because they either failed in a retriable way on execution, or were dropped elsewhere within the ATF system.&nbsp;
                                </p>
                                <p>
                                    Below is a simple walkthrough of the Store Consumer’s function:&nbsp;
                                </p>
                            </div>
                            <div>
                                <pre><code>repeat every second:
  1. poll tasks ready for execution from task store
  2. push tasks onto the right queues
  3. update task statuses</code></pre>
                            </div>
                            <div>
                                <p>
                                    The Store Consumer polls tasks that failed in earlier execution attempts. This helps with the at-least-once guarantee that the ATF system provides. More details on how the Store Consumer polls new and previously failed tasks is presented in the <a href="https://paper.dropbox.com/doc/How-we-designed-Dropboxs-ATF-an-async-task-framework--A~wmq5aW48OkHns4LzkM~o6zAg-cf95JuxevqilF2iWWATj6#:uid=342792671048375002388848&amp;h2=Lifecycle-of-a-task">Lifecycle of a task</a> section below.
                                </p>
                                <p>
                                    <b>Queue<br></b> ATF uses AWS <a href="https://aws.amazon.com/sqs/">Simple Queue Service</a> (SQS) to queue tasks internally. These queues act as a buffer between the Store Consumer and Controllers (described below). Each <span>&lt;lambda, priority&gt;</span> &nbsp;pair gets a dedicated SQS queue. The total number of SQS queues used by ATF is <span>#lambdas x #priorities</span>.
                                </p>
                                <p>
                                    <b>Controller<br></b> Worker hosts are physical hosts dedicated for task execution. Each worker host has one controller process responsible for polling tasks from SQS queues in a background thread, and then pushing them onto process local buffered queues. The Controller is only aware of the lambdas it is serving and thus polls only the limited set of necessary queues.&nbsp;
                                </p>
                                <p>
                                    The Controller serves tasks from its process local queue as a response to <span>NextWork</span> RPCs. This is the layer where execution level task prioritization occurs. The Controller has different process level queues for tasks of different priorities and can thus prioritize tasks in response to <span>NextWork</span> RPCs.
                                </p>
                                <p>
                                    <b>Executor<br></b> The Executor is a process with multiple threads, responsible for the actual task execution. Each thread within an Executor process follows this simple loop:
                                </p>
                            </div>
                            <div>
                                <pre><code>while True:
  w = get_next_work()
  do_work(w)</code></pre>
                            </div>
                            <div>
                                <p>
                                    Each worker host has a single Controller process and multiple executor processes. Both the Controller and Executors work in a “pull” model, in which active loops continuously long-poll for new work to be done.
                                </p>
                                <p>
                                    <b>Heartbeat and Status Controller (HSC)</b><br>
                                    The HSC serves RPCs for claiming a task for execution (<span>ClaimTask</span>), setting task status after execution (<span>SetResults</span>) and heartbeats during task execution (<span>Heartbeat</span>). <span>ClaimTask</span> requests originate from the Controllers in response to <span>NextWork</span> requests. <span>Heartbeat</span> and <span>SetResults</span> requests originate from executor processes during and after task execution. The HSC interacts with the task store to update the task status on the kind of request it receives.
                                </p>
                            </div>
                            <div>
                                <p id="data-model">
                                    <h2>
                                        Data model
                                    </h2>
                                </p>
                            </div>
                            <div>
                                <p>
                                    ATF uses our in-house metadata store, Edgestore, as a task store. Edgestore objects can be Entities or Associations (<span>assoc</span>), each of which can have user-defined attributes. Associations are used to represent relationships between entities. Edgestore supports indexing only on attributes of associations.
                                </p>
                                <p>
                                    Based on this design, we have two kinds of ATF-related objects in Edgestore. The ATF association stores scheduling information, such as the next scheduled timestamp at which the Store Consumer should poll a given task (either for the first time or for a retry). The ATF entity stores all task related information that is used to track the task state and payload for task execution. We query on associations from the Store Consumer in a pull model to pick up tasks ready for execution.
                                </p>
                            </div>
                            <div>
                                <p id="lifecycle-of-a-task">
                                    <h2>
                                        Lifecycle of a task
                                    </h2>
                                </p>
                            </div>
                            <div>
                                <ol>
                                    <li>Client performs a <span>Schedule</span> RPC call to <b>Frontend</b> with task information, including execution time.&nbsp;
                                    </li>
                                    <li>Frontend creates Edgestore <span>entity</span> and <span>assoc</span> for the task.&nbsp;
                                    </li>
                                    <li>When it is time to process the task, <b>Store Consumer</b> pulls the task from <b>Edgestore</b> and pushes it to a related <b>SQS</b> queue.&nbsp;
                                    </li>
                                    <li>
                                        <b>Executor</b> makes <span>NextWork</span> RPC call to <b>Controller</b>, which pulls tasks from the <b>SQS</b> queue, makes a <span>ClaimTask</span> RPC to the HSC and then returns the task to the <b>Executor</b>.&nbsp;
                                    </li>
                                    <li>
                                        <b>Executor</b> invokes the callback for the task. While processing, <b>Executor</b> performs <span>Heartbeat</span> RPC calls to <b>Heartbeat and Status Controller (HSC)</b>. Once processing is done, <b>Executor</b> performs <span>TaskStatus</span> RPC call to <b>HSC</b>.&nbsp;
                                    </li>
                                    <li>Upon getting <span>Heartbeat</span> and <span>TaskStatus</span> RPC calls, <b>HSC</b> updates the <b>Edgestore</b> entity and <span>assoc</span>.
                                    </li>
                                </ol>
                                <p>
                                    Every state update in the lifecycle of a task is accompanied by an update to the next trigger timestamp in the <span>assoc</span>. This ensures that the Store Consumer pulls the task again if there is no change in state of the task within the next trigger timestamp. This helps ATF achieve its at-least-once delivery guarantee by ensuring that no task is dropped.
                                </p>
                                <p>
                                    Following are the task entity and association states in ATF and their corresponding timestamp updates:
                                </p>
                                <table>
                                    <tbody>
                                        <tr>
                                            <td>
                                                <p>
                                                    <b>Entity status</b>
                                                </p>
                                            </td>
                                            <td>
                                                <p>
                                                    <b>Assoc status</b>
                                                </p>
                                            </td>
                                            <td>
                                                <p>
                                                    <b>next trigger timestamp in Assoc</b>
                                                </p>
                                            </td>
                                            <td>
                                                <p>
                                                    <b>Comment</b>
                                                </p>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>
                                                <p>
                                                    <span>new</span>
                                                </p>
                                            </td>
                                            <td>
                                                <p>
                                                    <span>new</span>
                                                </p>
                                            </td>
                                            <td>
                                                <p>
                                                    <span>scheduled_timestamp</span> of the task
                                                </p>
                                            </td>
                                            <td>
                                                <p>
                                                    Pick up new tasks that are ready.&nbsp;
                                                </p>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>
                                                <p>
                                                    <span>enqueued</span>
                                                </p>
                                            </td>
                                            <td>
                                                <p>
                                                    <span>started</span>
                                                </p>
                                            </td>
                                            <td>
                                                <p>
                                                    <span>enqueued_timestamp</span> + <span>enqueue_timeout</span>
                                                </p>
                                            </td>
                                            <td>
                                                <p>
                                                    Re-enqueue task if it has been in <span>enqueued</span> state for too long. This can happen if the queue loses data or the controller goes down after polling the queue and before the task is claimed.
                                                </p>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>
                                                <p>
                                                    <span>claimed</span>
                                                </p>
                                            </td>
                                            <td>
                                                <p>
                                                    <span>started</span>
                                                </p>
                                            </td>
                                            <td>
                                                <p>
                                                    <span>claimed_timestamp</span> + <span>claim_timeout</span>
                                                </p>
                                            </td>
                                            <td>
                                                <p>
                                                    Re-enqueue if task is claimed but never transfered to <span>processing</span>. This can happen if Controller is down after claiming a task. Task status is changed to <span>enqueued</span> after re-enqueue.
                                                </p>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>
                                                <p>
                                                    <span>processing</span>
                                                </p>
                                            </td>
                                            <td>
                                                <p>
                                                    <span>started</span>
                                                </p>
                                            </td>
                                            <td>
                                                <p>
                                                    <span>heartbeat_timestamp</span> + <span>heartbeat_timeout</span>`
                                                </p>
                                            </td>
                                            <td>
                                                <p>
                                                    Re-enqueue if task hasn’t sent <span>heartbeat</span> for too long. This can happen if Executor is down. Task status is changed to <span>enqueued</span> after re-enqueue.&nbsp;
                                                </p>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>
                                                <p>
                                                    <span>retriable failure</span>
                                                </p>
                                            </td>
                                            <td>
                                                <p>
                                                    started
                                                </p>
                                            </td>
                                            <td>
                                                <p>
                                                    compute <span>next_timestamp</span> according to backoff logic
                                                </p>
                                            </td>
                                            <td>
                                                <p>
                                                    Exponential backoff for tasks with retriable failure.&nbsp;
                                                </p>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>
                                                <p>
                                                    <span>success</span>
                                                </p>
                                            </td>
                                            <td>
                                                <p>
                                                    <span>completed</span>
                                                </p>
                                            </td>
                                            <td>
                                                <p>
                                                    N/A
                                                </p>
                                            </td>
                                            <td>
                                                
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>
                                                <p>
                                                    <span>fatal_failure</span>
                                                </p>
                                            </td>
                                            <td>
                                                <p>
                                                    <span>completed</span>
                                                </p>
                                            </td>
                                            <td>
                                                <p>
                                                    N/A
                                                </p>
                                            </td>
                                            <td>
                                                
                                            </td>
                                        </tr>
                                    </tbody>
                                </table>
                                <p>
                                    The store consumer polls for tasks based on the following query:
                                </p>
                                <p>
                                    <span>assoc_status= &amp;&amp; next_timestamp&lt;=time.now()<br></span>
                                </p>
                                <p>
                                    Below is the state machine that defines task state transitions:&nbsp;<br>
                                </p>
                            </div>
                            <div>
                                    <figure>
                                        <img src="https://localhost/cms/content/dam/dropbox/tech-blog/en-us/2020/11/atf/diagrams/Techblog-ATF-720x225px-2.png" aria-hidden="false" alt="Task State Transitions [Fig 2]" height="450" width="1440">
                                    </figure>
                                </div>
                            <div>
                                <p id="-achieving-guarantees">
                                    <h2>
                                        Achieving guarantees
                                    </h2>
                                </p>
                            </div>
                            <div>
                                <p>
                                    <b>At-least-once task execution<br></b> At-least-once execution is guaranteed in ATF by retrying a task until it completes execution (which is signaled by a <span>Success</span> or a <span>FatalFailure</span> state). All ATF system errors are implicitly considered retriable failures, and lambda owners have an option of marking tasks with a <span>RetriableFailure</span> state. Tasks might be dropped from the ATF execution pipeline in different parts of the system through transient RPC failures and failures on dependencies like Edgestore or SQS. These transient failures at different parts of the system do not affect the at-least-once guarantee, though, because of the system of timeouts and re-polling from Store Consumer.
                                </p>
                                <p>
                                    <b>No concurrent task execution<br></b> Concurrent task execution is avoided through a combination of two methods in ATF. First, tasks are explicitly claimed through an exclusive task state (<span>Claimed</span>) before starting execution. Once the task execution is complete, the task status is updated to one of <span>Success</span>, <span>FatalFailure</span> or <span>RetriableFailure</span>. A task can be claimed only if its existing task state is <span>Enqueued</span> (retried tasks go to the <span>Enqueued</span> state as well once they are re-pushed onto SQS).
                                </p>
                                <p>
                                    However, there might be situations where once a long running task starts execution, its heartbeats might fail repeatedly yet the task execution continues. ATF would retry this task by polling it from the store consumer because the heartbeat timeouts would’ve expired. This task can then be claimed by another worker and lead to concurrent execution.&nbsp;<br>
                                </p>
                                <p>
                                    To avoid this situation, there is a termination logic in the Executor processes whereby an Executor process terminates itself as soon as three consecutive heartbeat calls fail. Each heartbeat timeout is large enough to eclipse three consecutive heartbeat failures. This ensures that the Store Consumer cannot pull such tasks before the termination logic ends them—the second method that helps achieve this guarantee.
                                </p>
                                <p>
                                    <b>Isolation<br></b> Isolation of lambdas is achieved through dedicated worker clusters, dedicated queues, and dedicated per-lambda scheduling quotas. In addition, isolation across different priorities within the same lambda is likewise achieved through dedicated queues and scheduling bandwidth.
                                </p>
                                <p>
                                    <b>Delivery latency<br></b> ATF use cases do not require ultra-low task delivery latencies. Task delivery latencies on the order of a couple of seconds are acceptable. Tasks ready for execution are periodically polled by the Store Consumer and this period of polling largely controls the task delivery latency. Using this as a tuning lever, ATF can achieve different delivery latencies as required. Increasing poll frequency reduces task delivery latency and vice versa. Currently, we have calibrated ATF to poll for ready tasks once every two seconds.
                                </p>
                            </div>
                            <div>
                                <p id="ownership-model">
                                    <h2>
                                        Ownership model
                                    </h2>
                                </p>
                            </div>
                            <p>
                                    ATF is designed to be a self-serve framework for developers at Dropbox. The design is very intentional in driving an ownership model where lambda owners own all aspects of their lambdas’ operations. To promote this, all lambda worker clusters are owned by the lambda owners. They have full control over operations on these clusters, including code deployments and capacity management. Each executor process is bound to one lambda. Owners have the option of deploying multiple lambdas on their worker clusters simply by spawning new executor processes on their hosts.
                                </p>
                            <div>
                                <p id="-extending-atf">
                                    <h2>
                                        Extending ATF
                                    </h2>
                                </p>
                            </div>
                            
                            <div>
                                <p id="conclusion">
                                    <h2>
                                        Conclusion
                                    </h2>
                                </p>
                            </div>
                            <p>
                                    We hope this post helps engineers elsewhere to develop better async task frameworks of their own. Many thanks to everyone who worked on this project: Anirudh Jayakumar, Deepak Gupta, Dmitry Kopytkov, Koundinya Muppalla, Peng Kang, Rajiv Desai, Ryan Armstrong, Steve Rodrigues, Thomissa Comellas, Xiaonan Zhang and Yuhuan Du.<br>
                                    &nbsp;
                                </p>
                        </div></div>